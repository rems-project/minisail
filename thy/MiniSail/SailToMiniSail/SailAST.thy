(* generated by Ott 0.30 from: /home/markw/github/sail_minisail/language/sail.ott *)
theory SailAST
imports Main Native_Word.Uint32
begin

section \<open>Sail AST\<close>

type_synonym string = String.literal

hide_const id

datatype "value" = Val

datatype "loop" = While | Until

type_synonym 'a annot = "'a"

(*hide_const id*)


type_synonym "x" = "string" \<comment> \<open>identifier\<close>
type_synonym "ix" = "string" \<comment> \<open>infix identifier\<close>
datatype id =  \<comment> \<open>Identifier\<close>
   id  "x"  
 | operator  "x"   \<comment> \<open>remove infix status\<close>

datatype kid =  \<comment> \<open>kinded IDs: Type, Int, and Order variables\<close>
   var  "x"  

datatype base_effect =  \<comment> \<open>effect\<close>
   BE_rreg    \<comment> \<open>read register\<close>
 | BE_wreg    \<comment> \<open>write register\<close>
 | BE_rmem    \<comment> \<open>read memory\<close>
 | BE_rmemt    \<comment> \<open>read memory and tag\<close>
 | BE_wmem    \<comment> \<open>write memory\<close>
 | BE_eamem    \<comment> \<open>signal effective address for writing memory\<close>
 | BE_exmem    \<comment> \<open>determine if a store-exclusive (ARM) is going to succeed\<close>
 | BE_wmv    \<comment> \<open>write memory, sending only value\<close>
 | BE_wmvt    \<comment> \<open>write memory, sending only value and tag\<close>
 | BE_barr    \<comment> \<open>memory barrier\<close>
 | BE_depend    \<comment> \<open>dynamic footprint\<close>
 | BE_undef    \<comment> \<open>undefined-instruction exception\<close>
 | BE_unspec    \<comment> \<open>unspecified values\<close>
 | BE_nondet    \<comment> \<open>nondeterminism, from $nondet$\<close>
 | BE_escape    \<comment> \<open>potential exception\<close>
 | BE_config    \<comment> \<open>configuration option\<close>

datatype kind =  \<comment> \<open>base kind\<close>
   K_type    \<comment> \<open>kind of types\<close>
 | K_int    \<comment> \<open>kind of natural number size expressions\<close>
 | K_order    \<comment> \<open>kind of vector order specifications\<close>
 | K_bool    \<comment> \<open>kind of constraints\<close>

datatype nexp =  \<comment> \<open>numeric expression, of kind Int\<close>
   Nexp_id  "id"   \<comment> \<open>abbreviation identifier\<close>
 | Nexp_var  "kid"   \<comment> \<open>variable\<close>
 | Nexp_constant  "integer"   \<comment> \<open>constant\<close>
 | Nexp_app  "id" "nexp list"   \<comment> \<open>app\<close>
 | Nexp_times  "nexp" "nexp"   \<comment> \<open>product\<close>
 | Nexp_sum  "nexp" "nexp"   \<comment> \<open>sum\<close>
 | Nexp_minus  "nexp" "nexp"   \<comment> \<open>subtraction\<close>
 | Nexp_exp  "nexp"   \<comment> \<open>exponential\<close>
 | Nexp_neg  "nexp"   \<comment> \<open>unary negation\<close>

datatype effect = 
   Effect_set  "base_effect list"   \<comment> \<open>effect set\<close>

datatype kinded_id =  \<comment> \<open>optionally kind-annotated identifier\<close>
   KOpt_kind  "kind" "kid"   \<comment> \<open>kind-annotated variable\<close>

datatype order =  \<comment> \<open>vector order specifications, of kind Order\<close>
   Ord_var  "kid"   \<comment> \<open>variable\<close>
 | Ord_inc    \<comment> \<open>increasing\<close>
 | Ord_dec    \<comment> \<open>decreasing\<close>

datatype "typ" =  \<comment> \<open>type expressions, of kind Type\<close>
   Typ_internal_unknown   
 | Typ_id  "id"   \<comment> \<open>defined type\<close>
 | Typ_var  "kid"   \<comment> \<open>type variable\<close>
 | Typ_fn  "typ list" "typ" "effect"   \<comment> \<open>Function (first-order only)\<close>
 | Typ_bidir  "typ" "typ" "effect"   \<comment> \<open>Mapping\<close>
 | Typ_tup  "typ list"   \<comment> \<open>Tuple\<close>
 | Typ_app  "id" "typ_arg list"   \<comment> \<open>type constructor application\<close>
 | Typ_exist  "kinded_id list" "n_constraint" "typ"  
and typ_arg =  \<comment> \<open>type constructor arguments of all kinds\<close>
   A_nexp  "nexp"  
 | A_typ  "typ"  
 | A_order  "order"  
 | A_bool  "n_constraint"  
and n_constraint =  \<comment> \<open>constraint over kind Int\<close>
   NC_equal  "nexp" "nexp"  
 | NC_bounded_ge  "nexp" "nexp"  
 | NC_bounded_gt  "nexp" "nexp"  
 | NC_bounded_le  "nexp" "nexp"  
 | NC_bounded_lt  "nexp" "nexp"  
 | NC_not_equal  "nexp" "nexp"  
 | NC_set  "kid" "integer list"  
 | NC_or  "n_constraint" "n_constraint"  
 | NC_and  "n_constraint" "n_constraint"  
 | NC_app  "id" "typ_arg list"  
 | NC_var  "kid"  
 | NC_true   
 | NC_false   

datatype typ_pat =  \<comment> \<open>type pattern\<close>
   TP_wild   
 | TP_var  "kid"  
 | TP_app  "id" "typ_pat list"  

datatype lit =  \<comment> \<open>literal constant\<close>
   L_unit   
 | L_zero   
 | L_one   
 | L_true   
 | L_false   
 | L_num  "integer"   \<comment> \<open>natural number constant\<close>
 | L_hex  "string"   \<comment> \<open>bit vector constant, C-style\<close>
 | L_bin  "string"   \<comment> \<open>bit vector constant, C-style\<close>
 | L_string  "string"   \<comment> \<open>string constant\<close>
 | L_undef    \<comment> \<open>undefined-value constant\<close>
 | L_real  "string"  

datatype quant_item =  \<comment> \<open>kinded identifier or Int constraint\<close>
   QI_id  "kinded_id"   \<comment> \<open>optionally kinded identifier\<close>
 | QI_constraint  "n_constraint"   \<comment> \<open>constraint\<close>
 | QI_constant  "kinded_id list"  

datatype 'a pat =  \<comment> \<open>pattern\<close>
   P_lit ( annot_pat : "'a annot" ) "lit"   \<comment> \<open>literal constant pattern\<close>
 | P_wild ( annot_pat : "'a annot" )   \<comment> \<open>wildcard\<close>
 | P_or ( annot_pat : "'a annot" ) "'a pat" "'a pat"   \<comment> \<open>pattern disjunction\<close>
 | P_not ( annot_pat : "'a annot" ) "'a pat"   \<comment> \<open>pattern negation\<close>
 | P_as ( annot_pat : "'a annot" ) "'a pat" "id"   \<comment> \<open>named pattern\<close>
 | P_typ ( annot_pat : "'a annot" ) "typ" "'a pat"   \<comment> \<open>typed pattern\<close>
 | P_id ( annot_pat : "'a annot" ) "id"   \<comment> \<open>identifier\<close>
 | P_var ( annot_pat : "'a annot" ) "'a pat" "typ_pat"   \<comment> \<open>bind pattern to type variable\<close>
 | P_app ( annot_pat : "'a annot" ) "id" "'a pat list"   \<comment> \<open>union constructor pattern\<close>
 | P_vector ( annot_pat : "'a annot" ) "'a pat list"   \<comment> \<open>vector pattern\<close>
 | P_vector_concat ( annot_pat : "'a annot" ) "'a pat list"   \<comment> \<open>concatenated vector pattern\<close>
 | P_tup ( annot_pat : "'a annot" ) "'a pat list"   \<comment> \<open>tuple pattern\<close>
 | P_list ( annot_pat : "'a annot" ) "'a pat list"   \<comment> \<open>list pattern\<close>
 | P_cons ( annot_pat : "'a annot" ) "'a pat" "'a pat"   \<comment> \<open>Cons patterns\<close>
 | P_string_append ( annot_pat : "'a annot" ) "'a pat list"   \<comment> \<open>string append pattern, x ^^ y\<close>

datatype typquant =  \<comment> \<open>type quantifiers and constraints\<close>
   TypQ_tq  "quant_item list"  
 | TypQ_no_forall    \<comment> \<open>empty\<close>

datatype 'a mpat =  \<comment> \<open>Mapping pattern. Mostly the same as normal patterns but only constructible parts\<close>
   MP_lit "'a annot" "lit"  
 | MP_id "'a annot" "id"  
 | MP_app "'a annot" "id" "'a mpat list"  
 | MP_vector "'a annot" "'a mpat list"  
 | MP_vector_concat "'a annot" "'a mpat list"  
 | MP_tup "'a annot" "'a mpat list"  
 | MP_list "'a annot" "'a mpat list"  
 | MP_cons "'a annot" "'a mpat" "'a mpat"  
 | MP_string_append "'a annot" "'a mpat list"  
 | MP_typ "'a annot" "'a mpat" "typ"  
 | MP_as "'a annot" "'a mpat" "id"  

datatype 'a internal_loop_measure =  \<comment> \<open>internal syntax for an optional termination measure for a loop\<close>
   Measure_none   
 | Measure_some  "'a exp"  
and 'a exp =  \<comment> \<open>expression\<close>
   E_block ( annot_e : "'a annot" ) "'a exp list"   \<comment> \<open>sequential block\<close>
 | E_id ( annot_e : "'a annot" ) "id"   \<comment> \<open>identifier\<close>
 | E_lit ( annot_e : "'a annot" ) "lit"   \<comment> \<open>literal constant\<close>
 | E_cast ( annot_e : "'a annot" ) "typ" "'a exp"   \<comment> \<open>cast\<close>
 | E_app ( annot_e : "'a annot" ) "id" "'a exp list"   \<comment> \<open>function application\<close>
 | E_app_infix ( annot_e : "'a annot" ) "'a exp" "id" "'a exp"   \<comment> \<open>infix function application\<close>
 | E_tuple ( annot_e : "'a annot" ) "'a exp list"   \<comment> \<open>tuple\<close>
 | E_if ( annot_e : "'a annot" ) "'a exp" "'a exp" "'a exp"   \<comment> \<open>conditional\<close>
 | E_loop ( annot_e : "'a annot" ) "loop" "'a internal_loop_measure" "'a exp" "'a exp"  
 | E_for ( annot_e : "'a annot" ) "id" "'a exp" "'a exp" "'a exp" "order" "'a exp"   \<comment> \<open>for loop\<close>
 | E_vector ( annot_e : "'a annot" ) "'a exp list"   \<comment> \<open>vector (indexed from 0)\<close>
 | E_vector_access ( annot_e : "'a annot" ) "'a exp" "'a exp"   \<comment> \<open>vector access\<close>
 | E_vector_subrange ( annot_e : "'a annot" ) "'a exp" "'a exp" "'a exp"   \<comment> \<open>subvector extraction\<close>
 | E_vector_update ( annot_e : "'a annot" ) "'a exp" "'a exp" "'a exp"   \<comment> \<open>vector functional update\<close>
 | E_vector_update_subrange ( annot_e : "'a annot" ) "'a exp" "'a exp" "'a exp" "'a exp"   \<comment> \<open>vector subrange update, with vector\<close>
 | E_vector_append ( annot_e : "'a annot" ) "'a exp" "'a exp"   \<comment> \<open>vector concatenation\<close>
 | E_list ( annot_e : "'a annot" ) "'a exp list"   \<comment> \<open>list\<close>
 | E_cons ( annot_e : "'a annot" ) "'a exp" "'a exp"   \<comment> \<open>cons\<close>
 | E_record ( annot_e : "'a annot" ) "'a fexp list"   \<comment> \<open>struct\<close>
 | E_record_update ( annot_e : "'a annot" ) "'a exp" "'a fexp list"   \<comment> \<open>functional update of struct\<close>
 | E_field ( annot_e : "'a annot" ) "'a exp" "id"   \<comment> \<open>field projection from struct\<close>
 | E_case ( annot_e : "'a annot" ) "'a exp" "'a pexp list"   \<comment> \<open>pattern matching\<close>
 | E_let ( annot_e : "'a annot" ) "'a letbind" "'a exp"   \<comment> \<open>let expression\<close>
 | E_assign ( annot_e : "'a annot" ) "'a lexp" "'a exp"   \<comment> \<open>imperative assignment\<close>
 | E_sizeof ( annot_e : "'a annot" ) "nexp"   \<comment> \<open>the value of $nexp$ at run time\<close>
 | E_return ( annot_e : "'a annot" ) "'a exp"   \<comment> \<open>return $'a exp$ from current function\<close>
 | E_exit ( annot_e : "'a annot" ) "'a exp"   \<comment> \<open>halt all current execution\<close>
 | E_ref ( annot_e : "'a annot" ) "id"  
 | E_throw ( annot_e : "'a annot" ) "'a exp"  
 | E_try ( annot_e : "'a annot" ) "'a exp" "'a pexp list"  
 | E_assert ( annot_e : "'a annot" ) "'a exp" "'a exp"   \<comment> \<open>halt with error message $'a exp$ when not $'a exp$. exp' is optional.\<close>
 | E_var ( annot_e : "'a annot" ) "'a lexp" "'a exp" "'a exp"   \<comment> \<open>This is an internal node for compilation that demonstrates the scope of a local mutable variable\<close>
 | E_internal_plet ( annot_e : "'a annot" ) "'a pat" "'a exp" "'a exp"   \<comment> \<open>This is an internal node, used to distinguised some introduced lets during processing from original ones\<close>
 | E_internal_return ( annot_e : "'a annot" ) "'a exp"   \<comment> \<open>For internal use to embed into monad definition\<close>
 | E_internal_value ( annot_e : "'a annot" ) "value"   \<comment> \<open>For internal use in interpreter to wrap pre-evaluated values when returning an action\<close>
 | E_constraint ( annot_e : "'a annot" ) "n_constraint"  
and 'a lexp =  \<comment> \<open>lvalue expression\<close>
   LEXP_id ( annot_lexp : "'a annot" ) "id"   \<comment> \<open>identifier\<close>
 | LEXP_deref ( annot_lexp : "'a annot" ) "'a exp"  
 | LEXP_memory ( annot_lexp : "'a annot" ) "id" "'a exp list"   \<comment> \<open>memory or register write via function call\<close>
 | LEXP_cast ( annot_lexp : "'a annot" ) "typ" "id"  
 | LEXP_tup ( annot_lexp : "'a annot" ) "'a lexp list"   \<comment> \<open>multiple (non-memory) assignment\<close>
 | LEXP_vector_concat ( annot_lexp : "'a annot" ) "'a lexp list"   \<comment> \<open>vector concatenation L-exp\<close>
 | LEXP_vector ( annot_lexp : "'a annot" ) "'a lexp" "'a exp"   \<comment> \<open>vector element\<close>
 | LEXP_vector_range ( annot_lexp : "'a annot" ) "'a lexp" "'a exp" "'a exp"   \<comment> \<open>subvector\<close>
 | LEXP_field ( annot_lexp : "'a annot" ) "'a lexp" "id"   \<comment> \<open>struct field\<close>
and 'a fexp =  \<comment> \<open>field expression\<close>
   FE_Fexp "'a annot" "id" "'a exp"  
and 'a pexp =  \<comment> \<open>pattern match\<close>
   Pat_exp "'a annot" "'a pat" "'a exp"  
 | Pat_when "'a annot" "'a pat" "'a exp" "'a exp"  
and 'a letbind =  \<comment> \<open>let binding\<close>
   LB_val (annot_letbind : "'a annot") "'a pat" "'a exp"   \<comment> \<open>let, implicit type ($'a pat$ must be total)\<close>

datatype index_range =  \<comment> \<open>index specification, for bitfields in register types\<close>
   BF_single  "nexp"   \<comment> \<open>single index\<close>
 | BF_range  "nexp" "nexp"   \<comment> \<open>index range\<close>
 | BF_concat  "index_range" "index_range"   \<comment> \<open>concatenation of index ranges\<close>

datatype type_union =  \<comment> \<open>type union constructors\<close>
   Tu_ty_id  "typ" "id"  

datatype typschm =  \<comment> \<open>type scheme\<close>
   TypSchm_ts  "typquant" "typ"  

datatype 'a mpexp = 
   MPat_pat "'a annot" "'a mpat"  
 | MPat_when "'a annot" "'a mpat" "'a exp"  

datatype  'a pexp_funcl = PEXP_funcl "'a pexp"
datatype 'a reg_id = 
   RI_id "'a annot" "id"  

datatype type_def_aux =  \<comment> \<open>type definition body\<close>
   TD_abbrev "id" "typquant" "typ_arg"   \<comment> \<open>type abbreviation\<close>
 | TD_record "id" "typquant" "(typ*id) list" "bool"   \<comment> \<open>struct type definition\<close>
 | TD_variant "id" "typquant" "type_union list" "bool"   \<comment> \<open>tagged union type definition\<close>
 | TD_enum "id" "id list" "bool"   \<comment> \<open>enumeration type definition\<close>
 | TD_bitfield "id" "typ" "(id*index_range) list"   \<comment> \<open>register mutable bitfield type definition\<close>

type_synonym "val_spec_aux" = "typschm * id  * (string => string option) * bool"
datatype 'a mapcl =  \<comment> \<open>mapping clause (bidirectional pattern-match)\<close>
   MCL_bidir "'a annot" "'a mpexp" "'a mpexp"  
 | MCL_forwards "'a annot" "'a mpexp" "'a exp"  
 | MCL_backwards "'a annot" "'a mpexp" "'a exp"  

datatype tannot_opt =  \<comment> \<open>optional type annotation for functions\<close>
   Typ_annot_opt_none   
 | Typ_annot_opt_some  "typquant" "typ"  

datatype 'a rec_opt =  \<comment> \<open>optional recursive annotation for functions\<close>
   Rec_nonrec    \<comment> \<open>non-recursive\<close>
 | Rec_rec    \<comment> \<open>recursive without termination measure\<close>
 | Rec_measure  "'a pat" "'a exp"   \<comment> \<open>recursive with termination measure\<close>

datatype effect_opt =  \<comment> \<open>optional effect annotation for functions\<close>
   Effect_opt_none    \<comment> \<open>no effect annotation\<close>
 | Effect_opt_effect  "effect"  

datatype 'a funcl =  \<comment> \<open>function clause\<close>
   FCL_Funcl "'a annot" "id" "'a pexp_funcl"  

datatype 'a alias_spec =  \<comment> \<open>register alias expression forms\<close>
   AL_subreg "'a annot" "'a reg_id" "id"  
 | AL_bit "'a annot" "'a reg_id" "'a exp"  
 | AL_slice "'a annot" "'a reg_id" "'a exp" "'a exp"  
 | AL_concat "'a annot" "'a reg_id" "'a reg_id"  

datatype type_def = 
   TD_aux "type_def_aux"  

datatype val_spec = 
   VS_aux "val_spec_aux"  

datatype 'a mapdef =  \<comment> \<open>mapping definition (bidirectional pattern-match function)\<close>
   MD_mapping "'a annot" "id" "tannot_opt" "'a mapcl list"  

datatype 'a fundef =  \<comment> \<open>function definition\<close>
   FD_function "'a annot" "'a rec_opt" "tannot_opt" "effect_opt" "'a funcl list"  

datatype default_spec =  \<comment> \<open>default kinding or typing assumption\<close>
   DT_order  "order"  

datatype 'a dec_spec =  \<comment> \<open>register declarations\<close>
   DEC_reg "'a annot" "effect" "effect" "typ" "id"  
 | DEC_config "'a annot" "id" "typ" "'a exp"  
 | DEC_alias "'a annot" "id" "'a alias_spec"  
 | DEC_typ_alias "'a annot" "typ" "id" "'a alias_spec"  

datatype 'a scattered_def =  \<comment> \<open>scattered function and union type definitions\<close>
   SD_function "'a annot" "'a rec_opt" "tannot_opt" "effect_opt" "id"   \<comment> \<open>scattered function definition header\<close>
 | SD_funcl "'a annot" "'a funcl"   \<comment> \<open>scattered function definition clause\<close>
 | SD_variant "'a annot" "id" "typquant"   \<comment> \<open>scattered union definition header\<close>
 | SD_unioncl "'a annot" "id" "type_union"   \<comment> \<open>scattered union definition member\<close>
 | SD_mapping "'a annot" "id" "tannot_opt"  
 | SD_mapcl "'a annot" "id" "'a mapcl"  
 | SD_end "'a annot" "id"   \<comment> \<open>scattered definition end\<close>

datatype prec = 
   Infix  
 | InfixL  
 | InfixR  

datatype 'a loop_measure = 
   Loop "loop" "'a exp"  

datatype 'a def =  \<comment> \<open>top-level definition\<close>
   DEF_type "type_def"   \<comment> \<open>type definition\<close>
 | DEF_fundef "'a fundef"   \<comment> \<open>function definition\<close>
 | DEF_mapdef "'a mapdef"   \<comment> \<open>mapping definition\<close>
 | DEF_val "'a letbind"   \<comment> \<open>value definition\<close>
 | DEF_spec "val_spec"   \<comment> \<open>top-level type constraint\<close>
 | DEF_fixity "prec" "integer" "id"   \<comment> \<open>fixity declaration\<close>
 | DEF_overload "id" "id list"   \<comment> \<open>operator overload specification\<close>
 | DEF_default "default_spec"   \<comment> \<open>default kind and type assumptions\<close>
 | DEF_scattered "'a scattered_def"   \<comment> \<open>scattered function and type definition\<close>
 | DEF_measure "id" "'a pat" "'a exp"   \<comment> \<open>separate termination measure declaration\<close>
 | DEF_loop_measures "id" "'a loop_measure list"   \<comment> \<open>separate termination measure declaration\<close>
 | DEF_reg_dec "'a dec_spec"   \<comment> \<open>register declaration\<close>
 | DEF_internal_mutrec "'a fundef list"   \<comment> \<open>internal representation of mutually recursive functions\<close>
 | DEF_pragma "string" "string"    \<comment> \<open>compiler directive\<close>

datatype 'a opt_default =  \<comment> \<open>optional default value for indexed vector expressions\<close>
   Def_val_empty "'a annot"  
 | Def_val_dec "'a annot" "'a exp"  

datatype 'a defs =  \<comment> \<open>definition sequence\<close>
   Defs "'a def list"  


end



